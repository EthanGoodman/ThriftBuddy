from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, EmailStr, Field
from sqlalchemy import text
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session

from db.session import get_db
from db.models import User
from helpers.passwords import hash_password, verify_password

from datetime import datetime, timedelta
import os
import jwt



router = APIRouter()


# ---------- Schemas ----------
class RegisterRequest(BaseModel):
    email: EmailStr
    password: str = Field(min_length=8, max_length=128)
    display_name: str | None = Field(default=None, max_length=80)


class UserOut(BaseModel):
    id: str
    email: EmailStr
    display_name: str | None
    email_verified: bool
    created_at: str

class LoginRequest(BaseModel):
    email: EmailStr
    password: str


class LoginResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"



# ---------- Helpers ----------
def normalize_email(email: str) -> str:
    return email.strip().lower()

def create_access_token(*, user_id: str, email: str) -> str:
    secret = os.getenv("JWT_SECRET", "dev-secret-change-me")
    exp_minutes = int(os.getenv("JWT_EXPIRE_MINUTES", "60"))
    payload = {
        "sub": user_id,
        "email": email,
        "exp": datetime.utcnow() + timedelta(minutes=exp_minutes),
        "iat": datetime.utcnow(),
    }
    return jwt.encode(payload, secret, algorithm="HS256")



# ---------- Route ----------
@router.post(
    "/register",
    response_model=UserOut,
    status_code=status.HTTP_201_CREATED,
)
def register(payload: RegisterRequest, db: Session = Depends(get_db)) -> UserOut:
    email_raw = payload.email.strip()
    email_norm = normalize_email(email_raw)

    # Quick existence check using the GENERATED column (email_normalized)
    existing = (
        db.query(User)
        .filter(text("email_normalized = :e"))
        .params(e=email_norm)
        .first()
    )
    if existing:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Email already registered",
        )

    # Hash password
    pw_hash = hash_password(payload.password)

    # Create user (email_normalized is generated by DB)
    user = User(
        email=email_raw,
        password_hash=pw_hash,
        display_name=(payload.display_name.strip() if payload.display_name else None),
        email_verified=False,
        is_active=True,
    )

    db.add(user)

    try:
        db.commit()
    except IntegrityError:
        # Handles race conditions where two requests try same email at once
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Email already registered",
        )

    db.refresh(user)

    return UserOut(
        id=str(user.id),
        email=user.email,
        display_name=user.display_name,
        email_verified=bool(user.email_verified),
        created_at=user.created_at.isoformat() if hasattr(user.created_at, "isoformat") else str(user.created_at),
    )

@router.post("/login", response_model=LoginResponse)
def login(payload: LoginRequest, db: Session = Depends(get_db)) -> LoginResponse:
    email_norm = normalize_email(payload.email)

    user = (
        db.query(User)
        .filter(text("email_normalized = :e"))
        .params(e=email_norm)
        .first()
    )

    # Don't reveal whether the email exists
    if not user or not user.password_hash:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials",
        )

    if not verify_password(payload.password, user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials",
        )

    try:
        if hasattr(user, "last_login_at"):
            user.last_login_at = datetime.utcnow()
            db.add(user)
            db.commit()
    except Exception:
        db.rollback()

    token = create_access_token(user_id=str(user.id), email=user.email)
    return LoginResponse(access_token=token)

